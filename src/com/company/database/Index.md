출처 : [망나니개발자님 블로그](https://mangkyu.tistory.com/96)

## Index

---

인덱스란 **추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조다**.

만약 이러한 테이블이 있다고 가정해보자

|first_name|age|
|:---:|:---:|
|김씨|15|
|이씨|30|
|박씨|25|
|김씨|20|
|이씨|10|

age = 20인 SQL문으로는 이렇게 짤 수 있다
```SQL
select ~~ where age = 20
```
하지만 이런식으로 컴퓨터에 명령을 내리게 되면 컴퓨터는 age가 20인걸 찾기 위해 모든 행을
뒤져볼 것이다.

만약 행이 1억개면? -> 1억개의 행을 모두 뒤져보게 된다

이렇게 되면 속도가 매우 느려지게 된다. 이럴 때 사용하는것이 **index**다

### 인덱스(Index)의 관리

DBMS는 Index를 **항상 최신의 정렬된 상태로 유지해야** 원하는 값을 빠르게 탐색할 수 있다.

그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며, 그에 따른 오버헤드가 발생한다.

- INSERT : 새로운 데이터에 대한 인덱스를 추가함
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스를 추가함

### 인덱스(Index)의 장점과 단점

- 장점
    - 테이블을 **조회하는 속도와 그에 따른 성능을 향상**시킬 수 있다.
    - 전반적인 **시스템의 부하를 줄일 수 있다**.

- 단점
    - 인덱스를 관리하기 위해 **DB의 약 10%에 해당하는 저장공간이 필요**하다.
    - 인덱스를 관리하기 위해 **추가 작업**이 필요하다
    - 인덱스를 잘못 사용할 경우 **오히려 성능이 저하되는 역효과가 발생할 수 있다**.

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면
**인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과**가 발생할 수 있다.

그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.

UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 했다.

만약 어떤 테이블에서 UPDATE와 DELETE가 빈번하게 발생하게 된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.

### 인덱스(Index)를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다.

<br>

## 인덱스(Index)의 자료구조

---

인덱스를 구현하기 위해서는 다양한 자료구조를 사용할 수 있는데,
가장 대표적인 **해시 테이블**과 **B+Tree**에 대해서 알아보자.

### 해시 테이블(Hash Table)

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로
**빠른 데이터 검색이 필요할 때 유용**하다.

해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조다.

![](https://velog.velcdn.com/images/kimnow/post/2c0c1cac-95d4-434c-8b70-e79b41c76bd4/image.png)

해시 테이블 기반의 DB 인덱스는 (데이터=컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용해
컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다.

해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.

하지만 DB인덱스에서 해시 테이블이 사용되는 경우는 **제한적**인데 그 이유는 해시가 **등호(=)연산에만 특화되었기 때문**이다.

해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해
**부등호 연산(>, <)이 자주 사용되는 DB 검색을 위해서는 해시 테이블이 적합하지 않다**.

### B+Tree

B+Tree는 DB의 인덱스를 위해 **자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조**다.
B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.

- 리프노드들은 LinkedList로 연결되어 있다.

- 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다.

이러한 이유로 **BTree의 리프노드들은 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화 하였다**.

비록 B+Tree는 O(log2n)의 시간 복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.

![](https://velog.velcdn.com/images/kimnow/post/b6b34785-0369-42d4-b616-e798534be958/image.png)

